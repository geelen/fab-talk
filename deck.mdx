import { Head } from 'mdx-deck'
import { FullScreenCode, Split } from 'mdx-deck/layouts'
import { CodeSurfer } from "mdx-deck-code-surfer"
import vsDark from "prism-react-renderer/themes/vsDark"

import Slab from './components/Slab'
import Layouts from './components/Layouts'
import Todo from './components/Todo'
import Video from './components/Video'
import Tweet from './components/Tweet'

export { default as theme } from './theme'

<Head>
  <title>Why Frontend Apps Need a Standard Runtime</title>
</Head>

<Slab lines={`
  1 1 70 100 WHY FRONTEND APPS NEED A
  3.2 0.9 50 700 STANDARD
  3.2 0.6 60 700 RUNTIME
`}/>

```notes
Notes are working!
```

---

# Disclaimer

---

This talk is... a "draft".

```notes
That is to say, potentially a rambling mess.
```

---

# Disclaimer 2

---

I work from home, I don't see humans very often

---

export default Layouts.Images([
  require('file-loader!./assets/prince.jpg'),
  require('file-loader!./assets/whitney.jpg'),
])

<Slab lines={`
  2 1 50 700 MY WORKMATES
`}/>

---

# Disclaimer 3

---

I'm not impartial

```notes
This is a talk about a shift I think is happening in the React ecosystem and the frontend ecosystem more generally, but I'm not just observing this.
```

---

export default Layouts.Gradient

![](./assets/Logo.svg)

```notes
I'm also working on a product in this space called Linc. And so while I'm not talking to you about that product, I... kinda started that product and this project for the same reasons. So I'm kinda trying to convince you all that this is what happening and then maybe we can chat afterwards about this Linc thing.
```

---

<Slab lines={`
  1 1 70 100 WHY FRONTEND APPS NEED A
  3.2 0.9 50 700 STANDARD
  3.2 0.6 60 700 RUNTIME
`}/>

```notes
Anyway, let's begin
```

---

<Slab lines={`
  3 0.8 100 700 BUT
  4 0.8 50 700 GLEN
`}/>

```notes
But first!
```

---

![](./assets/browsers.png)

---

export default Layouts.Light

![](./assets/waterfall.png)

---

## "RUNTIME"

Includes delivery

```notes
This is somewhat unique to web apps.
It's not always that important, but it usually is.
There are other platforms where delivery is important, but not in the same way.
```

---

<Slab lines={`
  1 1 70 100 WHY FRONTEND APPS NEED A
  3.2 0.9 50 700 STANDARD
  3.2 0.6 60 700 RUNTIME
`}/>

```notes
Ok so now we're finally ready to start this talk 
```

---

### Part One
# Beyond Static Rendering

---

export default Layouts.Light

![](./assets/waterfall.png)

```notes
Now, look at this graph. I'm not prepared enough to actually run this section as a demo so I'm going to point at this thing and try to get you to imagine what's going on.

Let's think about what this graph means. We can see we have an initial period of waiting, then the HTML content is on the screen, then we go off and load the JS, and then we render it locally.

In development, that works great. We have a powerful computer and an instantaneous network. We also have live-reload, so we don't have to spend much time here.

But in production, this process is one of the most important things to optimise.
```

---

export default Layouts.Light

![](./assets/waterfall-1.png)

```notes
By default, using something like React that wants to be 100% client-rendered, you usually send down a blank HTML page. Then the JS boots and the app works.

Who here deploys an app like this? Most of the time you're writing a product that requires sign-in, where people will be spending all day there, that sort of thing.

There's nothing wrong with this approach, but it doesn't suit all use cases.
```

---

export default Layouts.Image(
  require('file-loader!./assets/react foo talk/react foo talk.001.png')
)

---

export default Layouts.Image(
  require('file-loader!./assets/react foo talk/react foo talk.002.png')
)

---

export default Layouts.Image(
  require('file-loader!./assets/react foo talk/react foo talk.003.png')
)

---

# "NO DOWNSIDE"

---

export default Layouts.Image(
  require('file-loader!./assets/galaxy-brain-1.png')
, false)

# Serve inital HTML

---

## Gatsby, NextJS, etc.

---

export default Layouts.Light

![](./assets/waterfall-2.png)

---

export default Layouts.Light

![](./assets/tti.gif)

<figcaption>
  https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4
</figcaption>

---

export default Layouts.Light

![](./assets/javascript-processing-times.png)

<figcaption>
  https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4
</figcaption>

---

export default Layouts.Image(
  require('file-loader!./assets/galaxy-brain-2.png')
, false)

# Bundle Splitting

---

# Current best practice

---

# But we can do better

---

export default Layouts.Light

![](./assets/portals-1.jpg)

<figcaption>
  https://speakerdeck.com/siddharthkp/a-portal-to-the-future
</figcaption>

---

export default Layouts.Light

![](./assets/portals-2.jpg)

<figcaption>
  https://speakerdeck.com/siddharthkp/a-portal-to-the-future
</figcaption>

---

export default Layouts.Light

![](./assets/portals-3.jpg)

<figcaption>
  https://speakerdeck.com/siddharthkp/a-portal-to-the-future
</figcaption>

---

export default Layouts.Light

![](./assets/portals-4.jpg)

<figcaption>
  https://speakerdeck.com/siddharthkp/a-portal-to-the-future
</figcaption>

---

export default Layouts.Image(
  require('file-loader!./assets/galaxy-brain-3.png')
, false)

## Don't Rerender<br/>Things That Don't Change

---

## The Future of React

---

<Video videoId="eF7Ca06u58w"/>

---

export default Layouts.Light

<Tweet id="1057420260242931713" options={{conversation: 'none' }}/>

---

export default Layouts.Image(
  require('file-loader!./assets/galaxy-brain-4.png')
, false)

---

export default Layouts.Image(
  require('file-loader!./assets/galaxy-brain-4.png')
, false)

## Whatever the hell that just was

---

## React's Future is Server-Side

---

### Part Two
# Hosting Dynamic Frontend Apps

---

# Hosting Static Apps

* Simple
* Portable
* Can't really fail<br/>(You can still ship broken code tho)
* Scalable
* Efficient

```notes
We can get all these for dynamic too
```

---

# Host your own?

* Simple ü§∑‚Äç
* Portable üôÇ
* Can't really fail ‚ùå
* Scalable üò¨
* Efficient üò¨

---

# Serverless?

---

```js
exports.myHandler = async function(event, context) {
   // Called once per request
}
```

---

export default Layouts.Image(
  require('file-loader!./assets/fire-its-hot.png')
, false)

---

export default Layouts.Light

#### Netlify Functions

![](./assets/netlify-functions.png)

<figcaption>
  https://www.netlify.com/docs/functions/
</figcaption>

---

export default Layouts.Light

#### Now 2.0

![](./assets/now-1.png)

<figcaption>
  https://zeit.co/blog/now-2
</figcaption>

---

export default Layouts.Light

#### Now 2.0

![](./assets/now-2.png)

<figcaption>
  https://zeit.co/blog/now-2
</figcaption>

---

export default Layouts.Light

#### Now 2.0

![](./assets/now-3.png)

<figcaption>
  https://zeit.co/blog/now-2
</figcaption>

---

# Problems in üèù

---

> *[Lambda]* isn‚Äôt running your code in any environment more lightweight than running Node on your own machines.
> 
> What it does do is auto-scale those processes (somewhat clumsily). **That auto-scaling creates cold-starts**.

<figcaption>
  https://blog.cloudflare.com/cloud-computing-without-containers/
</figcaption>

---

> Cold starts happen **once** for<br/>each **concurrent execution** of your function.

<figcaption>
  https://hackernoon.com/im-afraid-you-re-thinking-about-aws-lambda-cold-starts-all-wrong-7d907f278a4f
</figcaption>

---

export default Layouts.Light

![](./assets/cold-start-serial.png)

<figcaption>
  https://hackernoon.com/im-afraid-you-re-thinking-about-aws-lambda-cold-starts-all-wrong-7d907f278a4f
</figcaption>

---

export default Layouts.Light

![](./assets/cold-start-parallel.png)

<figcaption>
  https://hackernoon.com/im-afraid-you-re-thinking-about-aws-lambda-cold-starts-all-wrong-7d907f278a4f
</figcaption>

---

# Serverless

* Simple ü§∑‚Äç
* Portable ü§ó
* Can't really fail ü§ó
* Scalable üò¨
* Efficient ‚ùå

---

export default Layouts.Image(
  require('file-loader!./assets/galaxy-brain-5.png')
, false)

## SERVERLESS<br/>SPECIFICALLY FOR FRONTEND

---

### Part Three
# Introducing<br/>Frontend Application Bundles (FABs)

---

### Part Three
# Introducing*<br/>Frontend Application Bundles (FABs)

\* super not ready to use yet, pls don't @ me

---

# Disclaimer 4

There's nothing worse than somebody coming up to talk about something that sounds cool that doesn't exist yet.<br/>Anyway sorry.

---

## Origins

* Started as product-specific `linc-vm`
* Full node environment isolation using `vm2`
* Technically possible to escape
* Good enough for prototyping

---

## üí™ V8:Isolate

* JS-only (not Node) isolation<br/>(How Chrome isolates tabs from each other)
* Extra-blazingly fast, even for JS
* Up to you to provide any global variables
* Linc's implementation using `isolated-vm`

<figcaption>
  https://github.com/laverdet/isolated-vm
</figcaption>

```notes
We're using an in-memory version of FS and providing a fetch-compatible network layer.
```

---

> A basic Node Lambda running no real code consumes 35 MB of memory. When you can share the runtime between all of the Isolates as we do, that drops to **around 3 MB**.

<figcaption>
  https://blog.cloudflare.com/cloud-computing-without-containers
</figcaption>

---

> Fundamentally V8 was **designed to be multi-tenant**... Node and similar runtimes were not, and it shows in the multi-tenant systems which are built atop it.

<figcaption>
  https://blog.cloudflare.com/cloud-computing-without-containers
</figcaption>

---

> Isolates start in 5 milliseconds...
> 
> You are actually running **closer to the metal** than any other form of cloud computing I‚Äôm aware of.

<figcaption>
  https://blog.cloudflare.com/cloud-computing-without-containers
</figcaption>

---

## Downsides

* V8:Isolate itself is too low-level
* Most server-side packages don't work out of the box
* Development workflow isn't great<br/>(Remember life before source maps?)

---

## FABs

A collection of tools for bundling frontend projects for `V8:Isolate` VMs.

---

## FABs

A collection of tools for bundling frontend projects for `V8:Isolate` VMs.

Also a big reason to use Linc.

---

## FAB specification

* Single file (.fab)
* Immutable (untouched once built)
* Fingerprinted (production settings included)
* Injectable (settings overridable per-request)
* Portable (simple wrappers for any host)

---

export default Layouts.Code

<CodeSurfer
  title="FAB file format"
  code={`my-app.b1c53da6.fab
  ‚îú‚îÄ‚îÄ settings.json
  ‚îú‚îÄ‚îÄ runtime.js
  ‚îî‚îÄ‚îÄ _assets
        ‚îú‚îÄ‚îÄ js
        ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.7fcd9566.js
        ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ ...
        ‚îî‚îÄ‚îÄ media
            ‚îú‚îÄ‚îÄ logo_default.e925f90a.svg
         ¬†¬† ‚îî‚îÄ‚îÄ ...`}
  lang="text"
  showNumbers={false}
  theme={vsDark}
  steps={[
    {},
    { lines: [1], notes: "Zipped using @fab/deterministic-zip" },
    { lines: [2], notes: "Production environment variables" },
    { lines: [3], notes: "V8-isolate JS bundle of entire app" },
    { range: [4, 10], notes: "All static assets for release included" },
  ]}
/>

---

## CLI Packages*

```
@fab/static - compile a FAB from a static dir
@fab/serve - host a FAB in a NodeJS express server
@fab/next - compile a NextJS project
@fab/compile - advanced compiler for SSR FABs
@fab/cf-workers - wrap FAB in a Cloudflare Worker
@fab/docker - wrap FAB in a Docker image 
```

<figcaption>* extremely work-in-progress omfg</figcaption>

---

## Follow along

* Me on twitter, `@glenmaddern`
* FAB on GitHub `https://github.com/fab-spec/fab`
* Sign up for Linc `http://linc.sh`

---

# Thanks!